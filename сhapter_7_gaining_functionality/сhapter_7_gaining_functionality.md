# Глава 7: Приобретаем функциональность

## В этой главе

- Создание функций
- Документирование функций
- Передача аргументов
- Возврат значений
- Организация программ с помощью функций

Функции помогают снизить повторяемость кода за счёт превращения часто встречающихся участков кода в независимые единицы, допускающие многократное использование. В этой главе вы напишете некоторые функции, которые превратят решение трудоёмких задач в настоящее развлечение.

---

## Роль функций

**Функции** — это мини-программы в составе ваших программ. Функции предназначены для выполнения конкретных задач в рамках основной программы, потребность в которых может возникать неоднократно.

Если вы уже прочитали какую-либо из предыдущих глав, то уже видели, как работают функции. Ниже приведён пример простой функции, в результате выполнения которой к концу строки добавляется символ `t`:

```javascript
function addt(aString) {
	aString += 't'
	return aString
}
```

Функции — фундаментальные элементы программирования на JS, и их использование регламентируется множеством правил, которые вы как JS-программист должны знать. Не расстраивайтесь, если вам не удастся запомнить сразу все детали работы функций. Некоторые абстрактные концепции станут для вас более понятными лишь после того, как вы накопите практический опыт работы с функциями, и, возможно, вам даже понадобится ещё раз прочитать эту главу. В конечном счёте для вас всё прояснится, так что смело двигайтесь вперёд!

---

## Терминология функций

Обсуждая функции, программисты используют терминологию, которую вам необходимо знать для того, чтобы понимать, о чём они говорят. Мы интенсивно используем эту терминологию не только в данной главе, но и на протяжении всей книги. Ниже кратко описаны профессиональные термины, с которыми вы будете сталкиваться в процессе работы с функциями.

---

### Определение функции

Объявление функции в коде ещё не означает, что она выполняется. Она просто создаётся и становится доступной для выполнения в более поздний момент времени. Создание функции с той целью, чтобы её можно было использовать позднее, называется **определением** функции.

Функция объявляется и определяется в программе или на веб-странице только один раз. Если же вы определите одну и ту же функцию более одного раза, то JS не сообщит об ошибке. В подобных случаях используется та версия функции, которая была определена последней.

Пример объявления функции:

```javascript
var myFunction = function () {}
```

или

```javascript
function myFunction() {}
```

---

### Заголовок функции

**Заголовок функции** — это часть определения функции, которая содержит ключевое слово `function`, имя функции и круглые скобки, например:

```javascript
function myFunction()
```

---

### Тело функции

**Тело функции** состоит из инструкций, заключённых в фигурные скобки:

```javascript
{
	// Тело функции
}
```

---

### Вызов функции

Использование функции осуществляется путём её **вызова**. Вызов функции приводит к выполнению инструкций, составляющих её тело:

```javascript
myFunction()
```

---

### Определение параметров и передача аргументов

**Параметры** — это имена, которые вы присваиваете элементам данных, предоставляемым функции. Предоставление аргументов функции при её вызове (в соответствии с определёнными для функции параметрами) программисты называют **передачей аргументов**.

Для определения параметров функции используется следующий синтаксис:

```javascript
function myFunction(parameter) {}
```

Для вызова функции с передачей ей аргумента используется следующий синтаксис:

```javascript
myFunction(myArgument)
```

---

### Возврат значения

Функции могут не только принимать входные данные из внешнего мира, но и передавать обратно значения по завершении своего выполнения. Этот процесс называется **возвратом значения**.

Для возврата значения используется ключевое слово `return`, например:

```javascript
return myValue
```

---

## Преимущества использования функций

```javascript
// Функция для сложения чисел, образующих массив

function addNumbers(numbersToAdd) {
	var sum = 0
	for (var i = 0; i < numbersToAdd.length; i++) {
		sum = sum + numbersToAdd[i]
	}
	return sum
}

var myNumbers1 = [2, 4, 2, 7]
var myNumbers2 = [3333, 222, 111]
var myNumbers3 = [777, 555, 777, 555]

var sum1 = addNumbers(myNumbers1)
var sum2 = addNumbers(myNumbers2)
var sum3 = addNumbers(myNumbers3)

document.write(sum1 + '<br>')
document.write(sum2 + '<br>')
document.write(sum3 + '<br>')
```

> **Примечание:** В оригинальном коде были ошибки в названиях переменных и в цикле перебора массива.

Блочные комментарии, предшествующие функции, следуют формату, специфицированному системой документирования JSDoc. Комментируя функцию с использованием этого формата, вы не только облегчаете чтение текста программы, но и делаете возможным использование этих комментариев для документирования своих программ. О системе документирования рассказано во врезке "Документирование JS с помощью JSDoc". Более подробно о системе JSDoc можно прочитать на сайте: [JSDoc](https://jsdoc.app).

Функции обеспечивают значительную экономию времени, усилий и объёма кода программы. Поначалу на написание полезной функции у вас может уйти больше времени, чем на написание JS-кода, расположенного вне функций, но в долгосрочной перспективе ваши программы будут лучше организованы, и если написание функций войдёт у вас в привычку, то во многих случаях вы избавите себя от ненужной головной боли.

---

### Документирование JS с помощью JSDoc

Считается хорошей практикой всегда документировать JS-код с помощью какой-либо стандартной системы. Наиболее широко используемой системой документирования JS, которая стала стандартом де-факто, является система JSDoc.

Язык JSDoc — это простой язык разметки, который может внедряться в файлы JS. Текущая версия JSDoc основана на системе JavaDoc, применяющейся для документирования кода, написанного на языке Java.

Аннотировав свои JS-файлы с помощью JSDoc, вы сможете использовать генератор документации, например jsdoc-toolkit, для создания HTML-файлов, документирующих код.

Разметка JSDoc окружается специальными тегами блочных (многострочных) комментариев. Единственное различие между разметкой JSDoc и обычными блочными комментариями JS состоит в том, что в первом случае разметка начинается символами `/**` и заканчивается символами `*/`, тогда как в последнем случае вслед за начальной косой чертой указывается лишь один символ "звёздочка".

Дополнительная "звёздочка" не препятствует использованию разметки JSDoc в качестве обычного блочного комментария, но при необходимости делает её частью генерируемой документации.

| Тег JSDoc      | Описание                                                                 |
| -------------- | ------------------------------------------------------------------------ |
| `@author`      | Имя разработчика                                                         |
| `@constructor` | Маркирует функцию как конструктор                                        |
| `@deprecated`  | Маркирует метод устаревшим и не рекомендуемым                            |
| `@exception`   | Описывает исключение, генерируемое методом; синоним тега `@throws`       |
| `@exports`     | Указывает член, экспортируемый модулем                                   |
| `@param`       | Описывает параметр метода                                                |
| `@private`     | Обозначает, что метод закрытый                                           |
| `@return`      | Описывает возвращаемое значение; синоним `@returns`                      |
| `@returns`     | Описывает возвращаемое значение; синоним `@return`                       |
| `@see`         | Описывает связь с другим объектом                                        |
| `@this`        | Задает тип объекта, на который указывает ключевое слово `this` в функции |
| `@throws`      | Описывает исключение, генерируемое методом                               |
| `@version`     | Версия библиотеки                                                        |

---

## Написание функций

Объявление функции должно записываться в определённом порядке. Оно состоит из следующих элементов, указанных в порядке их следования:

- Ключевое слово `function`;
- Имя функции;
- Круглые скобки, в которых может быть указан один или несколько параметров;
- Пара фигурных скобок, содержащих инструкции.

Иногда единственным назначением функции является вывод сообщения на экран веб-страницы. Хорошим примером этого может служить функция, отображающая текущую дату. Приведённая ниже функция выводит текущую дату в окне браузера:

```javascript
function getTheDate() {
	var rightNow = new Date()
	document.write(rightNow.toDateString())
}
```

По умолчанию возвращаемым значением функции является `undefined`, поэтому с технической точки зрения отображаемое консолью значение `undefined` является возвращаемым значением.

---

## Возврат значений

В примере, приведённом в предыдущем разделе, мы создали функцию, которая всего лишь отображает строку в окне браузера. После выполнения программа покидает функцию и переходит к инструкции, следующей за вызовом функции.

Закончив свою работу, большинство функций возвращают значение (отличное от `undefined`). Это значение можно использовать в остальной части программы. Приведён пример функции, возвращающей значение. Затем это значение присваивается переменной и выводится в окне консоли:

```javascript
// Возврат значения функцией
function getHello() {
	return 'Привет!'
}

var helloText = getHello()
console.log(helloText)
```

Как правило, инструкция `return` является последней инструкцией функции. Её выполнение означает выход из функции. Вы можете использовать эту инструкцию для возврата функцией любого литерального значения (например, строки "Привет!" или числа 3), значения переменной или выражения, а также объекта, массива и даже другой функции.

```javascript
// Возврат результата вычисления выражения
function getCircumference() {
	var radius = 12
	return 2 * Math.PI * radius
}

console.log(getCircumference())
```

## Передача и использование аргументов

Для того чтобы функция могла выполнять одни и те же действия с различным входными данными, у программиста должна быть возможность передавать эти данные функции. Такая возможность уже была продемонстрирована, где для передачи параметров использовались скобки после имени функции в ее объявлении.

Поначалу различные между параметрами и аргументами может не быть для вас очевидным. Вот в чем суть этого различия.

- Параметры - это имена, которые вы указываете в определении функции.
- Аргументы - это значения, которые вы передаете функции.

```javascript
// Определяем для функции myTacos два параметра
function myTacos(meat, produce) {}
```

При вызове функции (аргументы) указываются там, где в определении функции размещаются параметры. Очень важно, чтобы аргументы, передаваемые функции, были указаны в том порядке, в каком соответствующие им параметры следуют в определении функции

```javascript
myTacos('beef', 'onions')
```

Значения, преданные функции, становятся значениями локальным переменных в функции и принимают имена определенных для нее параметров.

В Функцию закладывается возможность вывода значений обоих аргументов на консоль. Передача аргументов - это все равно что использование инструкции `var` в функции, но только значения поступают извне функции.

```javascript
function myTacos(meat, produce) {
	console.log(meat) // Вывести "beef"
	console.log(produce) // Вывести "onions"
}

myTacos('beef', 'onions')
```

<i>В определении функции разрешается задавать до 255 параметров. Однако вероятность того, что у кого-то возникнет реальная потребность в функции с таким большим количеством параметров, чрезвычайно мала. Если вдруг обнаруживается, что вам нужна функция, число параметров в которой очень велико, то всегда имеет смысл подыскать лучший способ организации программы в интересах сохранения ясности и удобочитаемости кода.</i>

### Передача аргументов по значению

Если для передачи аргумента используется переменная, относящаяся к одному из примитивных (элементарных) типов данных, то говорят, что аргумент предается <i>по значению.</i> Это означает, что новая переменная, созданная для хранения значения в функции, полностью отделена от переменной, используемой для передачи аргумента, и что бы ни происходило с преданным значением после того, как оно окажется в функции, переменная снаружи функции не почувствует никаких изменений.

<b>В JS элементарными считаются следующие типы данных: <code>string, number, boolean, undefined, null</code></b>

### Передача аргументов по ссылке

В то время как переменные JS, принадлежащие к элементарным типам (строки, числа, болевые значения, <code>undefined, null</code>), передаются функциям по значению, объекты JS передаются <i>по ссылке.</i> Это означает, что в тех случаях, когда функции в качестве аргумента передается объект, любое изменения этого объекта внесенные в функции, влекут за собой изменения значений вне функции.

### Вызов функции с неполным числом аргументов

Количество аргументов, задаваемых при вызове функции, не обязано совпадать с количеством параметров, указанных в определении этой функции. Если в определении функции содержатся три параметра, но вы вызываете ее, задавая всего лишь два аргумента, то третий параметр создаст функции переменную, имеющую значение <code>undefined</code>.

### Аргументы по умолчанию

Если желательно, чтобы значения аргументов по умолчанию были отличными от <code>undefined,</code> то установите эти значения по своему усмотрению. Наиболее широко поддерживаемый и общепринятый способ реализации этого заключается в проверке значений аргументов в функции и установке значений по умолчанию, если типом данных аргумента является <code>undefined</code>

```javascript
function welcome(yourName) {
	if (typeof yourName === 'undefined') {
		yourName = 'друг'
	}
}

function welcome2(yourName = 'друг') {
	document.write('Привет, ' + yourName)
}
```

<i>К моменту публикации книги еще не все браузеры поддерживали такую возможность, и поэтому данный метод установки значений аргументов по умолчанию может работать не для всех пользователей вашей программы.</i>

### Вызов функции с количеством аргументов, превышающим количество параметров

Если при вызове функции количество аргументов превышает количество ее параметров, то для дополнительных аргументов локальные переменные не создаются, поскольку функции неизвестно, как к ним обращаться.

И все же существует один трюк, используя который вы сможете получить значения аргументов даже в том случае, если соответствующие им параметры отсутствуют. Это делается с помощью обьекта <code>arguments</code>.

### Получение значений аргументов с помощью обьекта <code>arguments</code>

Если вы не знаете заранее, сколько аргументов будет передано в функцию, то для получения значений аргументов воспользуйтесь обьектом <code>arguments</code>, который JS автоматически встраивает в функции.

Обьект <code>arguments</code> содержит массив всех аргументов, преданных функции. Осуществив в цикле перебор всех элементов массива (с помощью цикла <code>for</code> или <code>for...in</code>), вы сможете использовать все аргументы, даже если их количество может меняться от вызова к вызову.

## Область видимости функции

Переменные, создаются в функции путем передачи ей аргументов или использования ключевого слова <code>var</code>, доступны только функции. После выхода из функции созданные в ней переменные уничтожаются.

В то же время переменная, созданная в функции без использования ключевого слова <code>var</code>, становится <i>глобальной переменной</i>. Доступ к такой переменной и ее изменение возможны в любом месте программы.

<b><i>Случайное создание глобальной переменной является распространенным источником ошибок и дефектов в JS, поэтому следует всегда внимательно следить за ограничением области видимости переменных и не допускать создани е глобальных переменных, если только в этом нет острой необходимости.</i></b>

## Анонимные функции

В заголовке функции имя не является обязательной часть, так что вы можете. создавать функции, не имеющие имени. Поначалу это может казаться странным, поскольку такая функция подобна собаке без клички, которую невозможно позвать! Однако <i>анонимные функции</i> могут назначаться переменным при их создании, что оставляет вам те же возможности, как и в том случае, когда имя функции указывается в ее заголовке.

```javascript
var doTheThing = function (thingToDo) {
	document.write('Сделать следующее: ' + thingToDo)
}
```

### Различия между анонимными и именованными функциями

Между созданием именованной и присвоением анонимной функции переменной имеются важные и иногда полезные различия. Первое из них состоит в том, что анонимные функции, присвоенные переменной, существуют и могут вызываться лишь после выполнения операции присваивания. Доступ же к именованным функциям возможен в любом месте программы.

Суть второго различия заключается в том, что в случае анонимных функций значение переменной может быть в любом момент изменено, и ей может быть присвоена другая функция. Это делает механизм анонимных функций более гибким по сравнению с именованными функциями.

### Самовыполняющиеся анонимные функции

Другим полезным применением анонимных функций являются <i>самовыполняющиеся функции</i>.

Чтобы превратить обычную анонимную функцию в самовыполняющиеся, достаточно заключить ее в круглые скобки, а затем добавить пару круглых скобок и точку с запятой после них.

Преимуществом использования самовыполняющихся анонимных функций является то, что переменные, которые вы создаете в них, уничтожаются при выходе из функции. Благодаря этому вы избегаете конфликта имен переменных и предотвращаете утечку памяти, т.е. сохранение в памяти переменных, которые больше не используются.

```javascript
var myVariable = 'Я нахожусь вне функции.'(function () {
	var myVariable = 'Я нахожусь в это функции'
	console.log(myVariable)
})()
console.log(myVariable)
```

Разработчики веб-приложений регулярно используют анонимные функции для создания самых разнообразных эффектов на веб-страницах.

## Сделайте это снова с помощью рекурсии

Функции можно вызывать извне функции или в других функциях. Возможен даже вызов функции из самой себя. На языке программистов такой вызов называется <i>Рекурсией</i>.

Во многих ситуациях рекурсия эквивалентна циклу с той лишь особенностью, что повторяются инструкции, образующие тело функции. Приведен пример простой рекурсивной функции. Однако в этой рекурсивной функции имеется одна большая проблема. Выполнение этой функции никогда не завершится. Она будет бесконечно долго умножать числа, пока вы ее не остановите.

```javascript
function squareItUp(startingNumber) {
	var square = startingNumber * startingNumber
	console.log(square)
	squareItUp(square)
}
```

<b>Выполнение функции, вероятнее всего, приведет к аварийной остановке браузера. Разумеется, никакой вред браузеру нанесен не будет, но этого будет достаточно для того, чтобы вы внимательно просмотрели код и обнаружили в нем проблему.</b>

Представлен другой вариант функции <code>squareItUp()</code>, усовершенствованный за счет предоставления так называемого <i>базового случая</i>. <b>Базовый случай</b> - это условие, выполнение которого означает прерывание рекурсивного процесса и прекращение работы функции. Базовый случай должен предусматриваться для каждой рекурсивной функции.

```javascript
function squareItUp(startingNumber) {
	square = startingNumber * startingNumber
	if (square > 1000000) {
		console.log(square)
	} else {
		squareItUp(square)
	}
}
```

Вот это уже лучше! Но проблемы остались и у этой функции. Что если кто-то предаст функции отрицательное число, нуль или единицу? Любое из этих значений породит бесконечный цикл. Чтобы обезопасить себя в подобных ситуациях, необходимо ввести условие прерывания рекурсии.

Дополнительно введена проверка того, что аргумент не меньше и не равен 1 и что он представляет собой число. В любом из этих случаев выполнение функции немедленно прекразается.

```javascript
function squareItUp(startingNumber) {
	// Условия прекращения выполнения, неверный ввод
	if ((typeof startingNumber != 'number') || (startingNumber <= 1>)){
		return -1 // Выйти из функции
	}
	square = startingNumber * startingNumber;
	// Базовый случай
	if (square > 1000000) {
		console.log(square) // Вывести конечный результат
	} else {
		// Если базовые условие не выполяется, то выполнить снова
		squareItUp(square)
	}
}
```

## Функции, объявленные в других функциях

Функции могут обьявляться в других функциях.

```javascript
function turnIntoAMartian(myName) {
	function recallName(myName) {
		var martianName = myName + ' Марсианин'
	}
	recallName(myName)
	console.log(martianName) // Вернуть undefined
}
```

Пример показывает, как вложение функции в другую функцию создает другой уровень области видимости. К переменным, созданным во внутренней функции, невозможен непосредственный доступ извне. Для получения их значений требуется использование инструкции <code>return</code>ю

```javascript
function turnIntoAMartian(myName) {
	function recallName(myName) {
		var martianName = myName + ' Марсианин'
		return martianName
	}
	var martianName = recallName(myName)
	console.log(martianName)
}
```
